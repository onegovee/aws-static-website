AWSTemplateFormatVersion: 2010-09-09
Transform: AWS::LanguageExtensions
Description: simple email service and related configs

Parameters:
  ZoneName:
    Type: String
  ZoneId:
    Type: String
  RecipientEmails:
    Type: CommaDelimitedList
  RecipientFilters:
    Type: String
    Default: false
    AllowedValues:
      - true
      - false
  EmailBucketName:
    Type: String
  ForwardToAddress:
    Type: String

Conditions:
  RecipientFilterCond: !Equals [ !Ref RecipientFilters, true ]

Resources:

  CustomLambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
        - Sid: AssumeLambdaExecutionRole
          Effect: Allow
          Principal:
            Service: lambda.amazonaws.com
          Action: sts:AssumeRole
      ManagedPolicyArns:
      - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
      - PolicyName: SESDomainIdentityPolicy
        PolicyDocument:
          Version: '2012-10-17'
          Statement:
          - Sid: AllowSESDomainIdentityActions
            Effect: Allow
            Action:
            - ses:ListIdentities
            - ses:VerifyDomainDkim
            - ses:VerifyDomainIdentity
            - ses:SetActiveReceiptRuleSet
            - ses:DeleteIdentity
            Resource: "*"

  CustomBackedLambda:
    Type: AWS::Lambda::Function
    Properties:
      Description: Lambda function for lambda-backed cfn custom resource
      Runtime: python3.9
      Role: !GetAtt CustomLambdaExecutionRole.Arn
      Handler: index.lambda_handler
      Timeout: 90
      Code:
        ZipFile: | #py
          import boto3
          import cfnresponse
          import logging
          
          def lambda_handler(event, context):
            log = logging.getLogger()
            #log.setLevel(logging.INFO)
            print(event)
            
            try:
              ses = boto3.client('ses')
              ResourceType = event['ResourceType']
              RequestType = event['RequestType']
              responseData = {}
              records = []

              if ResourceType == "Custom::InvokeCustomLambda":
                ZoneName = event['ResourceProperties']['ZoneName']

                # Changes to custom resource properties will cause cfn to create a new resource and delete the old one
                # This means CREATE and UPDATE events are effectively the same
                if RequestType in {"Create", "Update"}:
                  print("Got CREATE/UPDATE request for " + ZoneName)

                  # Create DKIM tokens for identity verification
                  # Creating DKIM tokens also creates the identity
                  # https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/ses.html#SES.Client.verify_domain_dkim
                  dkim = ses.verify_domain_dkim(Domain=ZoneName)
                  tokens = dkim['DkimTokens']

                  # Create DNS records to complete identity verification
                  for DkimTokens in tokens:
                    record = {
                      "Name": "{dkim_token}._domainkey.{zone_name}".format(dkim_token=DkimTokens,zone_name=ZoneName),
                      "Type": "CNAME",
                      "TTL": "60",
                      "ResourceRecords": [
                        "{dkim_token}.dkim.amazonses.com".format(dkim_token=DkimTokens)
                      ]
                    }
                    records.append(record)

                  # Send data back to cfn
                  responseData['records'] = records
                  responseData['message'] = "Created verification identity for " + ZoneName

                # 'ResourceProperties' in DELETE events are the same as 'OldResourceProperties' in UPDATE events
                elif RequestType == "Delete":
                  print("Got DELETE request for " + ZoneName)
                  ses.delete_identity(Identity=ZoneName)
                  print("Deleted identity verification for " + ZoneName)
                  # This is here mainly for changes to the identity/ZoneName
                  # If a duplicate identity is submitted for verification
                  # The identity may be deleted but the DNS records will not
                  # And then magically restored even though logging will show it was deleted here

              elif ResourceType == "Custom::SetActiveRuleSet" and RequestType != "Delete":
                RuleSetName = event['ResourceProperties']['RuleSetName']
                print("Setting the following SES rule set as active: " + RuleSetName)
                ses.set_active_receipt_rule_set(RuleSetName=RuleSetName)

              else:
                print("Lambda got RequestType: " + RequestType + " but did nothing")

            # Send FAILED back to cfn for any unexpected error
            except Exception:
              log.exception('Signaling failure to CloudFormation.')
              cfnresponse.send(event, context, cfnresponse.FAILED, {})
            
            else:
              # Always send SUCCESS back to cfn if lambda did what it was supposed to do
              cfnresponse.send(event, context, cfnresponse.SUCCESS, responseData)

  SesDomainIdentityMail:
    Type: Custom::InvokeCustomLambda
    Properties:
      ServiceToken: !GetAtt CustomBackedLambda.Arn
      ZoneName: !Ref ZoneName

# The responseData returned from the custom resource is not persisted between change sets so
# Do not modify the RecordSetGroup if the corresponding SES identity has been verified and is in use
  SesDkimRecords:
    Type: AWS::Route53::RecordSetGroup
    Properties:
      Comment: DNS records to complete SES domain identity verification
      HostedZoneId: !Ref ZoneId
      RecordSets: !GetAtt SesDomainIdentityMail.records
  
  SesMxRecord:
    Type: AWS::Route53::RecordSet
    Properties:
      Comment: DNS record for SES to manage incoming email
      HostedZoneId: !Ref ZoneId
      Name: !Ref ZoneName
      TTL: 60
      Type: MX
      ResourceRecords:
      - !Sub "10 inbound-smtp.${AWS::Region}.amazonaws.com"

  SesReceiptRuleSet:
    Type: AWS::SES::ReceiptRuleSet

# Active rules sets can not be deleted  
  SesActiveRulesSetDefault:
    Type: Custom::SetActiveRuleSet
    Properties:
      ServiceToken: !GetAtt CustomBackedLambda.Arn
      RuleSetName: !Ref SesReceiptRuleSet

# Lambda for simple email parsing via SNS
  SimpleEmailParserLambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
        - Sid: AssumeLambdaExecutionRole
          Effect: Allow
          Principal:
            Service: lambda.amazonaws.com
          Action: sts:AssumeRole
      ManagedPolicyArns:
      - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole

  SimpleEmailParserLambda:
    Type: AWS::Lambda::Function
    Properties:
      Description: Lambda function for processing emails
      Runtime: python3.12
      Role: !GetAtt SimpleEmailParserLambdaExecutionRole.Arn
      Handler: index.lambda_handler
      Timeout: 90
      Code:
        ZipFile: | #py
          import json
          import boto3
          import botocore
          import email
          from email.header import decode_header
          
          ses = boto3.client('ses')

          def lambda_handler(event, context):
            print(event)

            records = event['Records']
            for record in records:
              message = record['Sns']['Message']
              print(message)
              json_msg = json.loads(message)
              content = json_msg['content']
              print(content)

              parsed_msg = email.message_from_string(content)

              try:
                if parsed_msg.is_multipart():
                  for part in parsed_msg.walk():
                    content_type = part.get_content_type()
                    if content_type == 'text/plain':
                      decoded_msg = decode_email_body(part)
                      print(decoded_msg)
                else:
                  decoded_msg = decode_email_body(parsed_msg)
                  print(decoded_msg)
              except botocore.exceptions.ClientError as error:
                raise error
          
          def decode_email_body(part):
            charset = part.get_content_charset()
            payload = part.get_payload(decode=True)
            decoded_msg = payload.decode(charset or 'utf-8', 'replace')
            return decoded_msg

  SimpleEmailParserSnsLambdaInvokePermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !GetAtt SimpleEmailParserLambda.Arn
      Action: lambda:InvokeFunction
      Principal: sns.amazonaws.com
      SourceAccount: !Ref AWS::AccountId
      # construct the arn to avoid a circular dependency
      SourceArn: !Sub arn:aws:sns:${AWS::Region}:${AWS::AccountId}:*

  SimpleEmailParserSnsTopic:
    Type: AWS::SNS::Topic
    DependsOn: SimpleEmailParserSnsLambdaInvokePermission
    Properties:
      Subscription:
        - Protocol: lambda
          Endpoint: !GetAtt SimpleEmailParserLambda.Arn
  
# Bucket and lambda for forwarding emails
  EmailBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Ref EmailBucketName
  
  EmailBucketPolicy:
    Type: AWS::S3::BucketPolicy
    Properties:
      Bucket: !Ref EmailBucket
      PolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Action:
              - s3:PutObject
            Principal:
              Service: ses.amazonaws.com
            Resource:
              - !Sub arn:aws:s3:::${EmailBucket}/*
            Condition:
              StringEquals:
                'aws:Referer':
                  - !Ref AWS::AccountId
  
  EmailForwarderLambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Sid: AssumeLambdaExecutionRole
            Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: S3ReadAccess
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Action:
                  - s3:ListBucket
                Effect: Allow
                Resource: '*'
              - Action:
                  - s3:GetObject
                Effect: Allow
                Resource: !Sub arn:aws:s3:::${EmailBucket}/*
              - Action:
                  - ses:SendRawEmail
                Effect: Allow
                Resource: !Sub arn:aws:ses:${AWS::Region}:${AWS::AccountId}:identity/*

  EmailForwarderLambda:
    Type: AWS::Lambda::Function
    Properties:
      Description: Lambda function for forwarding emails
      Runtime: python3.12
      Role: !GetAtt EmailForwarderLambdaExecutionRole.Arn
      Handler: index.lambda_handler
      Timeout: 90
      Environment:
        Variables:
          BUCKET_NAME: !Ref EmailBucket
          FORWARD_TO_ADDRESS: !Ref ForwardToAddress
      Code:
        ZipFile: | #py
          import os
          import boto3
          import email
          import re
          from botocore.exceptions import ClientError
          from email.mime.multipart import MIMEMultipart
          from email.mime.text import MIMEText
          from email.mime.application import MIMEApplication

          region = os.environ['AWS_REGION']
          bucket_name = os.environ['BUCKET_NAME']
          forward_to_address = os.environ['FORWARD_TO_ADDRESS']

          s3 = boto3.client("s3")
          ses = boto3.client('ses', region)

          def get_message_from_s3(recipient, message_id):
            object_key = (recipient + "/" + message_id)
            object_uri = "s3://%s/%s" % (bucket_name, object_key)

            # Get the email object from the S3 bucket.
            get_object_response = s3.get_object(
              Bucket=bucket_name,
              Key=object_key
            )
            file = get_object_response['Body'].read()
            file_dict = {
              "file": file,
              "path": object_uri
            }

            return file_dict
          
          def create_message(sender, forward_to_address, file_dict):
            # Parse the email body.
            mailobject = email.message_from_string(file_dict['file'].decode('utf-8'))

            # Create a new subject line.
            subject_original = mailobject['Subject']
            subject = "FW: " + subject_original

            # The body text of the email.
            separator = ";"
            body_text = ("The attached message was received from " 
                        + separator.join(mailobject.get_all('From'))
                        + ". This message is archived at " + file_dict['path']
                        )

            # The file name to use for the attached message. Uses regex to remove all
            # non-alphanumeric characters, and appends a file extension.
            filename = re.sub('[^0-9a-zA-Z]+', '_', subject_original) + ".eml"

            # Create a MIME container.
            msg = MIMEMultipart()
            # Create a MIME text part.
            text_part = MIMEText(body_text, _subtype="html")
            # Attach the text part to the MIME message.
            msg.attach(text_part)

            # Add subject, from and to lines.
            msg['Subject'] = subject
            msg['From'] = sender
            msg['To'] = forward_to_address

            # Create a new MIME object.
            att = MIMEApplication(file_dict["file"], filename)
            att.add_header("Content-Disposition", 'attachment', filename=filename)

            # Attach the file object to the message.
            msg.attach(att)

            message = {
              "Source": sender,
              "Destinations": forward_to_address,
              "Data": msg.as_string()
            }

            return message
          
          def send_email(message):
            source = message['Source']
            destinations = message['Destinations']
            data = message['Data']
            
            try:
              send_raw_email_response = ses.send_raw_email(
                Source=source,
                Destinations=[
                  destinations
                ],
                RawMessage={
                  'Data':data
                }
              )
            except ClientError as error:
              result = error.response['Error']['Message']
            
            else:
              result = "Email sent! Message ID: " + send_raw_email_response['MessageId']

            return result
          
          def lambda_handler(event, context):
            print(event)
            # Get the original sender
            sender_orig = event['Records'][0]['ses']['mail']['source']
            print("Original email sender: ", sender_orig)
            # Get the original recipient
            recipient_orig = event['Records'][0]['ses']['mail']['destination'][0]
            # Use the original recipient as the sender of the forwarded email
            # this is assumed to be under the verified domain
            sender_fwd = recipient_orig
            print("Original recipient / forward sender: ", sender_fwd)

            # Get the unique ID of the message. This corresponds to the name of the file in S3.
            message_id = event['Records'][0]['ses']['mail']['messageId']

            # Call functions to get message from S3, create a new message and send to forward-to address
            file_dict = get_message_from_s3(recipient_orig, message_id)
            message = create_message(sender_fwd, forward_to_address, file_dict)
            result = send_email(message)
            print(result)

  EmailForwarderSesLambdaInvokePermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !GetAtt EmailForwarderLambda.Arn
      Action: lambda:InvokeFunction
      Principal: ses.amazonaws.com
      SourceAccount: !Ref AWS::AccountId
      # construct the arn to avoid a circular dependency
      SourceArn: !Sub arn:aws:ses:${AWS::Region}:${AWS::AccountId}:receipt-rule-set/${SesReceiptRuleSet}:receipt-rule/*

  ReceiptRuleDefault:
    Type: AWS::SES::ReceiptRule
    Properties:
      RuleSetName: !Ref SesReceiptRuleSet
      Rule:
        Enabled: true
        ScanEnabled: true
        TlsPolicy: Require
        Recipients: !Ref RecipientEmails
        Actions:
          - SNSAction: 
              Encoding: UTF-8
              TopicArn: !Ref SimpleEmailParserSnsTopic
  
  ReceiptRule0:
    Type: AWS::SES::ReceiptRule
    DependsOn: EmailBucketPolicy
    Properties:
      RuleSetName: !Ref SesReceiptRuleSet
      After: !Ref ReceiptRuleDefault
      Rule:
        Enabled: true
        ScanEnabled: true
        TlsPolicy: Require
        Recipients:
          - !Select [0, !Ref RecipientEmails] 
        Actions:
          - S3Action:
              BucketName: !Ref EmailBucket
              ObjectKeyPrefix: !Select [0, !Ref RecipientEmails] 
          - LambdaAction:
              FunctionArn: !GetAtt EmailForwarderLambda.Arn
  
  ReceiptFilterBlock:
    Type: AWS::SES::ReceiptFilter
    Condition: RecipientFilterCond
    Properties:
      Filter:
        IpFilter:
          Policy: Block
          Cidr: 0.0.0.0/0

  ReceiptFilterAllow:
    Type: AWS::SES::ReceiptFilter
    Condition: RecipientFilterCond
    Properties:
      Filter:
        IpFilter:
          Policy: Allow
          Cidr: 209.85.0.0/16

Outputs:
  CustomLambdaOutput: 
    Description: Message from the SES domain verification custom resource
    Value: !GetAtt SesDomainIdentityMail.message